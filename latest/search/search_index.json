{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"<p>Atomix Cloud</p>  <p>Example</p>    <pre><code>// Get a string:string map\nm, err := atomix.GetMap[string, string](context.Background(), \"my-map\")\nif err != nil {\n    ...\n}\n\n// Write to the map\n_, err = m.Put(context.Background(), \"foo\", \"bar\")\nif err != nil {\n    ...\n}\n\n// Read from the map\nentry, err := m.Get(context.Background(), \"foo\")\nif err != nil {\n    ...\n}\n</code></pre>   <pre><code>// Create an Atomix instance\nAtomix atomix = new Atomix();\n\n// Get the \"foo\" map\nMap&lt;String, String&gt; map = atomix.getMap(\"foo\");\n\n// Write to the map\nmap.put(\"foo\", \"bar\");\n\n// Read from the map\nEntry&lt;string, string&gt; entry = map.get(\"foo\");\n</code></pre>","title":"Atomix"},{"location":"getting-started/","text":"","title":"Getting Started"},{"location":"getting-started/#getting-started","text":"","title":"Getting Started"},{"location":"about/","text":"","title":"Index"},{"location":"about/#about","text":"","title":"About"},{"location":"concepts/","text":"","title":"Index"},{"location":"concepts/#concepts","text":"","title":"Concepts"},{"location":"contributor-guide/","text":"","title":"Index"},{"location":"contributor-guide/#contributor-guide","text":"","title":"Contributor Guide"},{"location":"reference/","text":"","title":"Index"},{"location":"reference/#reference","text":"","title":"Reference"},{"location":"user-guide/","text":"","title":"Index"},{"location":"user-guide/#user-guide","text":"","title":"User Guide"},{"location":"user-guide/clients/","text":"","title":"Index"},{"location":"user-guide/clients/#clients","text":"","title":"Clients"},{"location":"user-guide/clients/go/","text":"<p>This project provides a Go client for Atomix Cloud.</p>","title":"Go Client"},{"location":"user-guide/clients/go/#getting-started","text":"","title":"Getting Started"},{"location":"user-guide/clients/go/#installation","text":"<p>To install the Go client, use <code>go get</code>:</p> <pre><code>$ GO111MODULE=on go get github.com/atomix/go-client\n</code></pre>","title":"Installation"},{"location":"user-guide/clients/go/#usage","text":"<p>To use the client, import the client API:</p> <pre><code>import \"github.com/atomix/go-client/pkg/atomix\"\n</code></pre> <p>The <code>atomix</code> package provides functions for working with primitives using the default cluster configuration:</p> <pre><code>counter, err := atomix.GetCounter(context.Background(), \"my-counter\")\n</code></pre> <p>To use a non-default configuration, create a client by calling <code>NewClient</code>:</p> <pre><code>client := atomix.NewClient(atomix.WithBrokerPort(8000))\ncounter, err := client.GetCounter(context.Background(), \"my-counter\")\n</code></pre> <p>To create a distributed primitive, call the getter for the desired type, passing the name of the primitive and any additional primitive options:</p> <pre><code>lock, err := atomix.GetLock(context.Background(), \"my-lock\")\nif err != nil {\npanic(err)\n}\n</code></pre> <p>Primitive names are shared across all clients for a given scope within a given database. Any two primitives with the same name in the same scope and stored in the same database reference the same state machine regardless of client locations. So a <code>Lock</code> call in one container will block will block lock requests from all other containers until unlocked.</p> <pre><code>version, err := lock.Lock(context.Background())\nif err == nil {\n// Lock is acquired with version 'version'\n}\n</code></pre> <p>When a primitive is no longer in used by the client it can be closed with <code>Close</code> to reclaim resources:</p> <pre><code>lock.Close(context.Background())\n</code></pre>","title":"Usage"},{"location":"user-guide/clients/go/#counter","text":"<p>The <code>Counter</code> primitive is a distributed counter that supports atomic increment, decrement, and check-and-set operations. To create a counter, call <code>GetCounter</code> on the database in which to create the counter:</p> <pre><code>myCounter, err := atomix.GetCounter(context.Background(), \"my-counter\")\nif err != nil {\n    ...\n}\n\ndefer myCounter.Close(context.Background())\n</code></pre> <pre><code>count, err := myCounter.Get(context.Background())\nif err != nil {\n    ...\n}\n</code></pre> <pre><code>count, err = myCounter.Set(context.Background(), 10)\nif err != nil {\n    ...\n}\n</code></pre> <pre><code>count, err = myCounter.Increment(context.Background(), 1)\nif err != nil {\n    ...\n}\n</code></pre> <pre><code>count, err = myCounter.Decrement(context.Background(), 10)\nif err !=  nil {\n    ...\n}\n</code></pre>","title":"Counter"},{"location":"user-guide/clients/go/#leader-election","text":"<p>The <code>Election</code> primitive supports distributed leader election. Leader elections are implemented using first-in-first-out, but clients can sort election priority through various operations on the <code>Election</code> interface.</p> <p>To create an <code>Election</code>, call <code>GetElection</code> on the database in which to create the election:</p> <pre><code>myElection, err := atomix.GetElection(context.Background(), \"my-election\")\nif err != nil {\n    ...\n}\n\ndefer myElection.Close(context.Background())\n</code></pre> <p>Each <code>Election</code> object has a globally unique node ID which is used to identify the client and can be read by calling <code>ID()</code>:</p> <pre><code>id := myElection.ID()\n</code></pre> <p>The election ID is used to differentiate candidates and can be explicitly assigned by specifying a session ID when getting the election instance:</p> <pre><code>myElection, err := atomix.GetElection(context.Background(), \"my-election\", primitive.WithSessionID(\"node-1\"))\n</code></pre> <p>The current election <code>Term</code> can be retrieved by calling <code>GetTerm</code>:</p> <pre><code>term, err := myElection.GetTerm(context.Background())\nif err != nil {\n    ...\n}\n</code></pre> <p>The <code>Term</code> contains the complete state of the election: * <code>Leader</code> - the current leader ID * <code>Term</code> - a <code>uint64</code> per-leader, globally unique, monotonically increasing epoch for the leader * <code>Candidates</code> - a sequence of all candidates participating in the election in priority order,   including the current leader</p> <p>To enter the client into the election, call <code>Enter</code>:</p> <pre><code>term, err = myElection.Enter(context.Background())\nif err != nil {\n    ...\n}\n</code></pre> <p>The <code>Enter</code> call will return the resulting <code>Term</code> struct which can be used to determine whether the client won the election:</p> <pre><code>if term.Leader == myElection.ID() {\n    // This node is the leader\n}\n</code></pre> <p>Clients can leave the election by calling <code>Leave</code>:</p> <pre><code>err = myElection.Leave(context.Background())\nif err != nil {\n    ...\n}\n</code></pre> <p>When the leader leaves an election, a new leader will be elected. The <code>Watch</code> method can be used to watch the election for changes. When the leader or candidates changes, an event will be published to all watchers.</p> <pre><code>ch := make(chan election.Event)\nerr := myElection.Watch(context.Background(), ch)\nfor event := range ch {\n    ...\n}\n</code></pre>","title":"Leader Election"},{"location":"user-guide/clients/go/#indexedmap","text":"","title":"IndexedMap"},{"location":"user-guide/clients/go/#list","text":"","title":"List"},{"location":"user-guide/clients/go/#lock","text":"<p>The <code>Lock</code> primitive is a distributed lock that provides lock version numbers for fencing. To create a lock, call <code>GetLock</code> on the database in which to create the lock.</p> <p>_Note that it\u2019s recommended distributed locking be used with a strongly consistent database that implements a protocol like <code>raft</code>.</p> <pre><code>myLock, err := atomix.GetLock(context.Background(), \"my-lock\")\nif err != nil {\n    ...\n}\n\ndefer myLock.Close(context.Background())\n</code></pre> <p>To acquire the lock, call <code>Lock</code>:</p> <pre><code>version, err := myLock.Lock(context.Background())\nif err != nil {\n    ...\n}\n</code></pre> <p>If the lock is currently held by another client (or another <code>Lock</code> instance owned by the current client), the <code>Lock()</code> call will block until the lock is <code>Unlock</code>ed by the owning client. A timeout can be provided by the <code>Context</code>:</p> <pre><code>ctx := context.WithTimeout(context.Background(), 10 * time.Second)\nversion, err := myLock.Lock(ctx)\nif err != nil {\n    ...\n}\n</code></pre> <p>Successful calls to <code>Lock()</code> return a <code>uint64</code> lock version number. The lock version number is guaranteed to be unique and monotonically increasing, so it\u2019s suitable for fencing and optimistic locking.</p> <p>To determine whether the lock is currently held by any client, call <code>IsLocked</code>:</p> <pre><code>locked, err := myLock.IsLocked(context.Background())\nif err != nil {\n    ...\n}\n</code></pre> <p>A lock version number can also be passed using <code>WithVersion</code> to determine whether the lock is held by an owner with the given version number:</p> <pre><code>locked, err = myLock.IsLocked(context.Background(), atomixlock.WithVersion(version))\nif err != nil {\n    ...\n}\n</code></pre> <p>Once the client has finished with the lock, unlock it by calling <code>Unlock</code>:</p> <pre><code>unlocked, err := myLock.Unlock(context.Background())\nif err != nil {\n    ...\n}\n</code></pre> <p>Clients can also release any process\u2019s lock by passing the owner\u2019s lock version number:</p> <pre><code>unlocked, err = myLock.Unlock(context.Background(), lock.IfMatch(lock))\nif err != nil {\n    ...\n}\n</code></pre>","title":"Lock"},{"location":"user-guide/clients/go/#map","text":"<p>The <code>Map</code> primitive provides a distributed map that supports concurrency control through optimistic locking. Maps store <code>string</code> keys and <code>[]byte</code> values, and map entries are represented in return values as a <code>KeyValue</code> object with the following fields: * <code>Key</code> - the <code>string</code> map key * <code>Value</code> - the <code>[]byte</code> entry value * <code>Version</code> - a monotonically increasing, unique <code>int64</code> entry version suitable for use in optimistic locks</p> <p>To create a distributed map, get a <code>Database</code> and call <code>GetMap</code> on the database:</p> <pre><code>myMap, err := atomix.GetMap(context.Background(), \"my-map\")\nif err != nil {\n    ...\n}\n\ndefer myMap.Close(context.Background())\n</code></pre> <p>To put a value in a map, call <code>Put</code>:</p> <pre><code>entry, err := myMap.Put(context.Background(), \"foo\", []byte(\"bar\"))\nif err != nil {\n    ...\n}\n</code></pre> <p>The returned <code>Entry</code> contains the metadata for the entry that was written to the map. <code>Get</code> also returns the <code>Entry</code>:</p> <pre><code>entry, err = myMap.Get(context.Background(), \"foo\")\nif err != nil {\n    ...\n}\n</code></pre> <p>This entry metadata can be used for optimistic locking when updating the entry using the <code>IfMatch</code> option:</p> <pre><code>entry, err := myMap.Put(context.Background(), \"foo\", []byte(\"baz\"), _map.IfMatch(entry.ObjectMeta))\nif err != nil {\n    ...\n}\n</code></pre> <p>To remove a key from the map, call <code>Remove</code>:</p> <pre><code>entry, err = myMap.Remove(context.Background(), \"foo\")\nif err != nil {\n    ...\n}\n</code></pre> <p>Again, optimistic locking can be used when removing an entry:</p> <pre><code>entry, err = myMap.Remove(context.Background(), \"foo\", _map.IfMatch(entry.ObjectMeta))\nif err != nil {\n    ...\n}\n</code></pre> <p>Call <code>Clear</code> to remove all entries from the map:</p> <pre><code>err = myMap.Clear(context.Background())\nif err != nil {\n    ...\n}\n</code></pre> <p>The <code>Watch</code> method can be used to watch the map for changes. When the map is modified an event will be published to all watchers.</p> <pre><code>ch := make(chan _map.Event)\nerr := myMap.Watch(context.Background(), ch)\nfor event := range ch {\n    ...\n}\n</code></pre>","title":"Map"},{"location":"user-guide/clients/go/#set","text":"<p>The <code>Set</code> primitive is a partitioned distributed set. Set values are stored as <code>strings</code>. To create a set, call <code>GetSet</code> on the database in which to create the set:</p> <pre><code>mySet, err := atomix.GetSet(context.Background(), \"my-set\")\nif err != nil {\n    ...\n}\n\ndefer mySet.Close(context.Background())\n</code></pre> <p>To add an element to the set, call <code>Add</code>:</p> <pre><code>added, err := mySet.Add(context.Background(), \"foo\")\nif err != nil {\n    ...\n}\n</code></pre> <p>To check if the set contains an element, call <code>Contains</code>:</p> <pre><code>contains, err := mySet.Contains(context.Background(), \"foo\")\nif err != nil {\n    ...\n}\n</code></pre> <p>And to remove an element from the set, call <code>Remove</code>:</p> <pre><code>removed, err := mySet.Remove(context.Background(), \"foo\")\nif err != nil {\n    ...\n}\n</code></pre> <p>Or to remove all elements from the set, call <code>Clear</code>:</p> <pre><code>err := mySet.Clear(context.Background())\nif err != nil {\n    ...\n}\n</code></pre> <p>The <code>Watch</code> method can be used to watch the set for changes. When an element is added to or removed from the set, an event will be published to all watchers.</p> <pre><code>ch := make(chan set.Event)\nerr := mySet.Watch(context.Background(), ch)\nfor event := range ch {\n    ...\n}\n</code></pre>","title":"Set"},{"location":"user-guide/clients/go/#value","text":"<p>The <code>Value</code> primitive is a distributed <code>[]byte</code> value that supoorts atomic set-and-get and compare-and-set operations.</p> <pre><code>myValue, err := atomix.GetValue(context.Background(), \"my-value\")\nif err != nil {\n...\n}\n\ndefer myValue.Close(context.Background())\n</code></pre> <p>To set the value call <code>Set</code>:</p> <pre><code>meta, err := myValue.Set(context.Background(), []byte(\"Hello world!\"))\nif err != nil {\n...\n}\n</code></pre> <p>To get the current value use <code>Get</code>:</p> <pre><code>bytes, meta, err := myValue.Get(context.Background())\nif err != nil {\n...\n}\n</code></pre> <p>The <code>ObjectMeta</code> returned by <code>Get</code> and <code>Set</code> calls contains versioning information that can be used to perform atomic check-and-set operations using optimistic locking:</p> <pre><code>if string(bytes) == \"Hello world!\" {\n_, err := myValue.Set(context.Background(), []byte(\"Goodbye world.\"), value.IfMatch(meta))\n}\n</code></pre> <p>The <code>Watch</code> method can be used to watch the value for changes. Each time the value is updated, an event will be published to all watchers.</p> <pre><code>ch := make(chan value.Event)\nerr := myValue.Watch(context.Background(), ch)\nfor event := range ch {\n...\n}\n</code></pre>","title":"Value"},{"location":"user-guide/clients/java/","text":"<p>Java client library for Atomix 4</p>","title":"atomix-java-client"},{"location":"user-guide/drivers/","text":"","title":"Index"},{"location":"user-guide/drivers/#drivers","text":"","title":"Drivers"},{"location":"user-guide/drivers/local/","text":"<p>Local storage driver for Atomix Cloud.</p>","title":"Local Driver"},{"location":"user-guide/drivers/muti-raft/","text":"<p>Multi-Raft storage driver for Atomix Cloud.</p>","title":"Multi-Raft Driver"},{"location":"user-guide/primitives/counter/","text":"","title":"Counter"},{"location":"user-guide/primitives/counter/#counter","text":"","title":"Counter"},{"location":"user-guide/primitives/map/","text":"","title":"Map"},{"location":"user-guide/primitives/map/#map","text":"","title":"Map"}]}